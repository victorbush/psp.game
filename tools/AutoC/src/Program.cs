using System;
using System.IO;
using System.Xml.Serialization;

namespace AutoC
{
    internal class Program
    {
        private const string AutoGenCommentHeader = @"/*=========================================================
This file is automatically generated. Do not edit manually.
=========================================================*/
";

        /// <summary>
        /// Path to the config file.
        /// </summary>
        private const string ConfigFilePath = "config.xml";

        /// <summary>
        /// The character sequence that identifies the end of a function declaration. The first
        /// brace of the function definition is used, and the function declaration is created from
        /// the definition.
        /// </summary>
        private const string EndFlag = "{";

        /// <summary>
        /// The character sequence that identifies the beginning of a function.
        /// </summary>
        private const string StartFlag = "//##";

        /// <summary>
        /// The active configuration.
        /// </summary>
        private static Config Config;

        private static Chunk GetNextChunk(string src, int startIdx)
        {
            var chunk = new Chunk();
            chunk.Valid = false;

            var startFlagIdx = src.IndexOf(StartFlag, startIdx);
            if (startFlagIdx < 0)
            {
                return chunk;
            }

            var endFlagIdx = src.IndexOf(EndFlag, startFlagIdx + 1);
            if (endFlagIdx < 0)
            {
                return chunk;
            }

            // Get parameters
            var paramStartIdx = startFlagIdx + StartFlag.Length;
            var paramEndIdx = src.IndexOf("\n", paramStartIdx);
            chunk.Param = src.Substring(paramStartIdx, paramEndIdx - paramStartIdx).Trim();

            // Get chunk
            chunk.StartIdx = paramEndIdx;
            chunk.EndIdx = endFlagIdx;
            chunk.Text = src.Substring(chunk.StartIdx, chunk.EndIdx - chunk.StartIdx);

            // Add trailing semicolon for function declarations
            chunk.Text += ";\n";

            chunk.NextIdx = endFlagIdx + EndFlag.Length;
            chunk.Valid = true;

            return chunk;
        }

        private static Config LoadConfig()
        {
            Config config = null;
            var xs = new XmlSerializer(typeof(Config));

            try
            {
                // Only try to load config if it exists
                if (File.Exists(ConfigFilePath))
                {
                    using (var r = new FileStream(ConfigFilePath, FileMode.Open))
                    {
                        config = (Config)xs.Deserialize(r);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

            if (config == null)
            {
                config = new Config();
            }

            return config;
        }

        private static void Main(string[] args)
        {
            Config = LoadConfig();

            // Make sure output directory exists
            Directory.CreateDirectory(Config.OutputDirectory);

            // Process files in input dir
            foreach (var file in Directory.EnumerateFiles(Config.InputDirectory, "*.c", SearchOption.TopDirectoryOnly))
            {
                ProcessFile(file);
            }

            // Process sub-directories
            foreach (var dir in Directory.EnumerateDirectories(Config.InputDirectory, "", SearchOption.AllDirectories))
            {
                var fullPath = Path.GetFullPath(dir);

                // Check if should ignore this directory
                if (Config.IsDirectoryExcluded(fullPath))
                {
                    continue;
                }

                // Process files in the directory
                foreach (var file in Directory.EnumerateFiles(fullPath, "*.c", SearchOption.TopDirectoryOnly))
                {
                    ProcessFile(file);
                }
            }

            // Enable saving config to generate config or for debugging
            //SaveConfig(Config);
        }

        private static void ProcessFile(string filePath)
        {
            var fileName = Path.GetFileNameWithoutExtension(filePath);
            var src = File.ReadAllText(filePath);

            var publicHeaderPath = Path.Combine(Config.OutputDirectory, fileName + ".public.h");
            var publicHeaderText = "";

            var internalHeaderPath = Path.Combine(Config.OutputDirectory, fileName + ".internal.h");
            var internalHeaderText = "";

            var staticHeaderPath = Path.Combine(Config.OutputDirectory, fileName + ".static.h");
            var staticHeaderText = "";

            var chunk = GetNextChunk(src, 0);
            while (chunk.Valid)
            {
                if (chunk.Param == "static")
                {
                    staticHeaderText += chunk.Text;
                }
                else if (chunk.Param == "internal")
                {
                    internalHeaderText += chunk.Text;
                }
                else if (chunk.Param == "public")
                {
                    publicHeaderText += chunk.Text;
                }
                else
                {
                    Console.WriteLine("ERROR: Unknown access modifier: " + chunk.Param);
                }

                chunk = GetNextChunk(src, chunk.NextIdx);
            }

            // Write output text
            if (!string.IsNullOrWhiteSpace(publicHeaderText))
            {
                File.WriteAllText(publicHeaderPath, AutoGenCommentHeader + publicHeaderText);
            }

            if (!string.IsNullOrWhiteSpace(internalHeaderText))
            {
                File.WriteAllText(internalHeaderPath, AutoGenCommentHeader + internalHeaderText);
            }

            if (!string.IsNullOrWhiteSpace(staticHeaderText))
            {
                File.WriteAllText(staticHeaderPath, AutoGenCommentHeader + staticHeaderText);
            }
        }

        private static void SaveConfig(Config c)
        {
            var xs = new XmlSerializer(typeof(Config));

            try
            {
                using (var w = new FileStream(ConfigFilePath, FileMode.Create))
                {
                    xs.Serialize(w, c);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }

        private class Chunk
        {
            public int EndIdx { get; set; }

            public int NextIdx { get; set; }

            public string Param { get; set; }

            public int StartIdx { get; set; }

            public string Text { get; set; }

            public bool Valid { get; set; }
        }
    }
}